// broker_api.proto
syntax = "proto3";
package io.ringbroker.api;

option java_package = "io.ringbroker.api";
option java_outer_classname = "BrokerApi";

message Envelope {
  uint64 correlationId = 100;

  oneof kind {
    Message          publish = 1;
    BatchMessage     batch = 2;
    FetchRequest     fetch = 3;
    CommitRequest    commit = 4;
    CommittedRequest committed = 5;
    SubscribeRequest subscribe = 6;
    PublishReply     publishReply = 10;
    FetchReply       fetchReply = 11;
    CommitAck        commitAck = 12;
    CommittedReply   committedReply = 13;
    MessageEvent     messageEvent = 14;

    ReplicationAck   replication_ack = 15;

    // Internal broker<->broker protocol (additive)
    AppendRequest      append = 20;
    AppendBatchRequest append_batch = 21;
    SealRequest        seal = 22;
    EpochStatusRequest epoch_status = 23;
    BackfillRequest    backfill = 24;
    BackfillReply      backfill_reply = 25;
    OpenEpochRequest   open_epoch = 26;
    MetadataUpdate     metadata_update = 27;
  }
}

message Message {
  string topic = 1;
  int32  retries = 2;
  bytes  payload = 3;
  bytes  key = 4;
  int32  partition_id = 5;
}

message PublishReply {
  bool success = 1;
  string error = 2;
}

message CommitRequest {
  string topic = 1;
  string group = 2;
  int32  partition = 3;
  int64  offset = 4;
}
message CommitAck {
  bool success = 1;
}
message CommittedRequest {
  string topic = 1;
  string group = 2;
  int32  partition = 3;
}
message CommittedReply {
  int64 offset = 1;
}

message SubscribeRequest {
  string topic = 1;
  string group = 2;
  int64  offset = 3;
}
message MessageEvent {
  string topic = 1;
  int64  offset = 2;
  bytes  key = 3;
  bytes  payload = 4;
}

message FetchRequest {
  string topic = 1;
  string group = 2;
  int32  partition = 3;
  int64  offset = 4;
  int32  maxMessages = 5;
}

message BatchMessage {
  repeated Message messages = 1;
}

message FetchReply {
  repeated MessageEvent messages = 1;
  repeated int32 redirect_nodes = 2; // optional hint where to read if this node lacks the epoch
  enum Status {
    OK = 0;
    NOT_IN_PLACEMENT = 1;
    EPOCH_MISSING = 2;
  }
  Status status = 3;
}

message BackfillRequest {
  int32 partition_id = 1;
  int64 epoch = 2;
  int64 offset = 3;
  int32 max_bytes = 4;
}

message BackfillReply {
  bytes payload = 1;
  bool end_of_epoch = 2;
  repeated int32 redirect_nodes = 3;
}

message ReplicationAck {
  enum Status {
    SUCCESS = 0;
    ERROR_PERSISTENCE_FAILED = 1;
    ERROR_INVALID_REQUEST = 2;
    ERROR_REPLICA_NOT_READY = 3;
    ERROR_UNKNOWN = 4;
  }

  Status status = 1;
  string error_message = 2;
  int32 replica_node_id = 3;
  int64 offset = 4;
}

message AppendRequest {
  int32 partition_id = 1;
  int64 epoch = 2;
  int64 seq = 3;

  string topic = 4;
  int32  retries = 5;

  bytes  key = 6;
  bytes  payload = 7;
}

message AppendBatchRequest {
  int32 partition_id = 1;
  int64 epoch = 2;
  int64 base_seq = 3;

  string topic = 4;
  int32  retries = 5;

  repeated bytes keys = 6;
  repeated bytes payloads = 7;
}

message SealRequest {
  int32 partition_id = 1;
  int64 epoch = 2;
  bool  seal_only = 3; // if true, do not auto-create next epoch (used for rebalance choreography)
}

message EpochStatusRequest {
  int32 partition_id = 1;
  int64 epoch = 2;
}

// Control plane: open a new epoch on storage (fencing token)
message OpenEpochRequest {
  int32 partition_id = 1;
  int64 epoch = 2;
  int64 tie_breaker = 3; // e.g., placement version or owner id
}

// Metadata broadcast (leaderless, highest configVersion wins)
message MetadataUpdate {
  int32 partition_id = 1;
  int64 config_version = 2;
  repeated EpochConfig epochs = 3;
}

message EpochConfig {
  int64 epoch = 1;
  int64 start_seq = 2;
  int64 end_seq = 3;
  int32 ack_quorum = 4;
  repeated int32 storage_nodes = 5;
  int64 tie_breaker = 6;
}
